/* filetype.c generated by valac, the Vala compiler
 * generated from filetype.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <geanyplugin.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>


#define PEASY_TYPE_OBJECT (peasy_object_get_type ())
#define PEASY_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PEASY_TYPE_OBJECT, PeasyObject))
#define PEASY_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PEASY_TYPE_OBJECT, PeasyObjectClass))
#define PEASY_IS_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PEASY_TYPE_OBJECT))
#define PEASY_IS_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PEASY_TYPE_OBJECT))
#define PEASY_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PEASY_TYPE_OBJECT, PeasyObjectClass))

typedef struct _PeasyObject PeasyObject;
typedef struct _PeasyObjectClass PeasyObjectClass;
typedef struct _PeasyObjectPrivate PeasyObjectPrivate;

#define PEASY_TYPE_FILETYPE (peasy_filetype_get_type ())
#define PEASY_FILETYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PEASY_TYPE_FILETYPE, PeasyFiletype))
#define PEASY_FILETYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PEASY_TYPE_FILETYPE, PeasyFiletypeClass))
#define PEASY_IS_FILETYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PEASY_TYPE_FILETYPE))
#define PEASY_IS_FILETYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PEASY_TYPE_FILETYPE))
#define PEASY_FILETYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PEASY_TYPE_FILETYPE, PeasyFiletypeClass))

typedef struct _PeasyFiletype PeasyFiletype;
typedef struct _PeasyFiletypeClass PeasyFiletypeClass;
typedef struct _PeasyFiletypePrivate PeasyFiletypePrivate;
typedef struct _Block2Data Block2Data;
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))

struct _PeasyObject {
	GObject parent_instance;
	PeasyObjectPrivate * priv;
};

struct _PeasyObjectClass {
	GObjectClass parent_class;
};

struct _PeasyFiletype {
	PeasyObject parent_instance;
	PeasyFiletypePrivate * priv;
	GeanyFiletype _ft;
};

struct _PeasyFiletypeClass {
	PeasyObjectClass parent_class;
};

struct _Block2Data {
	int _ref_count_;
	GPtrArray* fts;
};


static gpointer peasy_filetype_parent_class = NULL;
extern GeanyPlugin* peasy_object_peasy_plugin;

GType peasy_object_get_type (void) G_GNUC_CONST;
GType peasy_filetype_get_type (void) G_GNUC_CONST;
enum  {
	PEASY_FILETYPE_DUMMY_PROPERTY,
	PEASY_FILETYPE_ID,
	PEASY_FILETYPE_EXTENSION,
	PEASY_FILETYPE_NAME,
	PEASY_FILETYPE_TITLE,
	PEASY_FILETYPE_DISPLAY_NAME,
	PEASY_FILETYPE_MIME_TYPE,
	PEASY_FILETYPE_ICON
};
GPtrArray* peasy_filetype_all_filetypes (void);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void _g_object_unref0_ (gpointer var);
static void __lambda4_ (Block2Data* _data2_, GeanyFiletype* ft);
PeasyFiletype* peasy_filetype_new (GeanyFiletype* ft);
PeasyFiletype* peasy_filetype_construct (GType object_type, GeanyFiletype* ft);
static void ___lambda4__gfunc (gconstpointer data, gpointer self);
PeasyObject* peasy_object_new (void);
PeasyObject* peasy_object_construct (GType object_type);
PeasyFiletype* peasy_filetype_get_by_id (GeanyFiletypeID id);
PeasyFiletype* peasy_filetype_get_by_name (const gchar* name);
PeasyFiletype* peasy_filetype_detect_from_file (const gchar* filename);
gint peasy_filetype_get_id (PeasyFiletype* self);
const gchar* peasy_filetype_get_extension (PeasyFiletype* self);
const gchar* peasy_filetype_get_name (PeasyFiletype* self);
const gchar* peasy_filetype_get_title (PeasyFiletype* self);
const gchar* peasy_filetype_get_display_name (PeasyFiletype* self);
const gchar* peasy_filetype_get_mime_type (PeasyFiletype* self);
GIcon* peasy_filetype_get_icon (PeasyFiletype* self);
static void peasy_filetype_finalize (GObject* obj);
static void _vala_peasy_filetype_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_ptr_array_unref0 (_data2_->fts);
		g_slice_free (Block2Data, _data2_);
	}
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void __lambda4_ (Block2Data* _data2_, GeanyFiletype* ft) {
	GeanyFiletype _tmp0_ = {0};
	PeasyFiletype* _tmp1_ = NULL;
	g_return_if_fail (ft != NULL);
	_tmp0_ = *ft;
	_tmp1_ = peasy_filetype_new (&_tmp0_);
	g_ptr_array_add (_data2_->fts, _tmp1_);
}


static void ___lambda4__gfunc (gconstpointer data, gpointer self) {
	__lambda4_ (self, data);
}


static gpointer _g_ptr_array_ref0 (gpointer self) {
	return self ? g_ptr_array_ref (self) : NULL;
}


GPtrArray* peasy_filetype_all_filetypes (void) {
	GPtrArray* result = NULL;
	Block2Data* _data2_;
	GPtrArray* _tmp0_ = NULL;
	GeanyPlugin* _tmp1_ = NULL;
	GeanyData* _tmp2_ = NULL;
	GPtrArray* _tmp3_ = NULL;
	GPtrArray* _tmp4_ = NULL;
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_tmp0_ = g_ptr_array_new_with_free_func (_g_object_unref0_);
	_data2_->fts = _tmp0_;
	_tmp1_ = peasy_object_peasy_plugin;
	_tmp2_ = (*_tmp1_).geany_data;
	_tmp3_ = (*_tmp2_).filetypes_array;
	g_ptr_array_foreach (_tmp3_, ___lambda4__gfunc, _data2_);
	_tmp4_ = _g_ptr_array_ref0 (_data2_->fts);
	result = _tmp4_;
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return result;
}


PeasyFiletype* peasy_filetype_construct (GType object_type, GeanyFiletype* ft) {
	PeasyFiletype * self = NULL;
	GeanyFiletype _tmp0_ = {0};
	g_return_val_if_fail (ft != NULL, NULL);
	self = (PeasyFiletype*) peasy_object_construct (object_type);
	_tmp0_ = *ft;
	self->_ft = _tmp0_;
	return self;
}


PeasyFiletype* peasy_filetype_new (GeanyFiletype* ft) {
	return peasy_filetype_construct (PEASY_TYPE_FILETYPE, ft);
}


PeasyFiletype* peasy_filetype_get_by_id (GeanyFiletypeID id) {
	PeasyFiletype* result = NULL;
	GeanyFiletype* ft = NULL;
	GeanyFiletypeID _tmp0_ = 0;
	GeanyFiletype* _tmp1_ = NULL;
	GeanyFiletype* _tmp2_ = NULL;
	GeanyFiletype* _tmp3_ = NULL;
	GeanyFiletype _tmp4_ = {0};
	PeasyFiletype* _tmp5_ = NULL;
	_tmp0_ = id;
	_tmp1_ = filetypes_index ((gint) _tmp0_);
	ft = _tmp1_;
	_tmp2_ = ft;
	if (_tmp2_ == NULL) {
		result = NULL;
		return result;
	}
	_tmp3_ = ft;
	_tmp4_ = *_tmp3_;
	_tmp5_ = peasy_filetype_new (&_tmp4_);
	result = _tmp5_;
	return result;
}


PeasyFiletype* peasy_filetype_get_by_name (const gchar* name) {
	PeasyFiletype* result = NULL;
	GeanyFiletype* ft = NULL;
	const gchar* _tmp0_ = NULL;
	GeanyFiletype* _tmp1_ = NULL;
	GeanyFiletype* _tmp2_ = NULL;
	GeanyFiletype* _tmp3_ = NULL;
	GeanyFiletype _tmp4_ = {0};
	PeasyFiletype* _tmp5_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = name;
	_tmp1_ = filetypes_lookup_by_name (_tmp0_);
	ft = _tmp1_;
	_tmp2_ = ft;
	if (_tmp2_ == NULL) {
		result = NULL;
		return result;
	}
	_tmp3_ = ft;
	_tmp4_ = *_tmp3_;
	_tmp5_ = peasy_filetype_new (&_tmp4_);
	result = _tmp5_;
	return result;
}


PeasyFiletype* peasy_filetype_detect_from_file (const gchar* filename) {
	PeasyFiletype* result = NULL;
	const gchar* _tmp0_ = NULL;
	GeanyFiletype* _tmp1_ = NULL;
	GeanyFiletype _tmp2_ = {0};
	PeasyFiletype* _tmp3_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	_tmp0_ = filename;
	_tmp1_ = filetypes_lookup_by_name (_tmp0_);
	_tmp2_ = *_tmp1_;
	_tmp3_ = peasy_filetype_new (&_tmp2_);
	result = _tmp3_;
	return result;
}


gint peasy_filetype_get_id (PeasyFiletype* self) {
	gint result;
	GeanyFiletype _tmp0_ = {0};
	GeanyFiletypeID _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->_ft;
	_tmp1_ = _tmp0_.id;
	result = (gint) _tmp1_;
	return result;
}


const gchar* peasy_filetype_get_extension (PeasyFiletype* self) {
	const gchar* result;
	GeanyFiletype _tmp0_ = {0};
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_ft;
	_tmp1_ = _tmp0_.extension;
	result = _tmp1_;
	return result;
}


const gchar* peasy_filetype_get_name (PeasyFiletype* self) {
	const gchar* result;
	GeanyFiletype _tmp0_ = {0};
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_ft;
	_tmp1_ = _tmp0_.name;
	result = _tmp1_;
	return result;
}


const gchar* peasy_filetype_get_title (PeasyFiletype* self) {
	const gchar* result;
	GeanyFiletype _tmp0_ = {0};
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_ft;
	_tmp1_ = _tmp0_.title;
	result = _tmp1_;
	return result;
}


const gchar* peasy_filetype_get_display_name (PeasyFiletype* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = filetypes_get_display_name (&self->_ft);
	result = _tmp0_;
	return result;
}


const gchar* peasy_filetype_get_mime_type (PeasyFiletype* self) {
	const gchar* result;
	GeanyFiletype _tmp0_ = {0};
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_ft;
	_tmp1_ = _tmp0_.mime_type;
	result = _tmp1_;
	return result;
}


GIcon* peasy_filetype_get_icon (PeasyFiletype* self) {
	GIcon* result;
	GeanyFiletype _tmp0_ = {0};
	GIcon* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_ft;
	_tmp1_ = _tmp0_.icon;
	result = _tmp1_;
	return result;
}


static void peasy_filetype_class_init (PeasyFiletypeClass * klass) {
	peasy_filetype_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->get_property = _vala_peasy_filetype_get_property;
	G_OBJECT_CLASS (klass)->finalize = peasy_filetype_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), PEASY_FILETYPE_ID, g_param_spec_int ("id", "id", "id", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PEASY_FILETYPE_EXTENSION, g_param_spec_string ("extension", "extension", "extension", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PEASY_FILETYPE_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PEASY_FILETYPE_TITLE, g_param_spec_string ("title", "title", "title", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PEASY_FILETYPE_DISPLAY_NAME, g_param_spec_string ("display-name", "display-name", "display-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PEASY_FILETYPE_MIME_TYPE, g_param_spec_string ("mime-type", "mime-type", "mime-type", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PEASY_FILETYPE_ICON, g_param_spec_object ("icon", "icon", "icon", G_TYPE_ICON, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void peasy_filetype_instance_init (PeasyFiletype * self) {
}


static void peasy_filetype_finalize (GObject* obj) {
	PeasyFiletype * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PEASY_TYPE_FILETYPE, PeasyFiletype);
	G_OBJECT_CLASS (peasy_filetype_parent_class)->finalize (obj);
}


GType peasy_filetype_get_type (void) {
	static volatile gsize peasy_filetype_type_id__volatile = 0;
	if (g_once_init_enter (&peasy_filetype_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PeasyFiletypeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) peasy_filetype_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PeasyFiletype), 0, (GInstanceInitFunc) peasy_filetype_instance_init, NULL };
		GType peasy_filetype_type_id;
		peasy_filetype_type_id = g_type_register_static (PEASY_TYPE_OBJECT, "PeasyFiletype", &g_define_type_info, 0);
		g_once_init_leave (&peasy_filetype_type_id__volatile, peasy_filetype_type_id);
	}
	return peasy_filetype_type_id__volatile;
}


static void _vala_peasy_filetype_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	PeasyFiletype * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PEASY_TYPE_FILETYPE, PeasyFiletype);
	switch (property_id) {
		case PEASY_FILETYPE_ID:
		g_value_set_int (value, peasy_filetype_get_id (self));
		break;
		case PEASY_FILETYPE_EXTENSION:
		g_value_set_string (value, peasy_filetype_get_extension (self));
		break;
		case PEASY_FILETYPE_NAME:
		g_value_set_string (value, peasy_filetype_get_name (self));
		break;
		case PEASY_FILETYPE_TITLE:
		g_value_set_string (value, peasy_filetype_get_title (self));
		break;
		case PEASY_FILETYPE_DISPLAY_NAME:
		g_value_set_string (value, peasy_filetype_get_display_name (self));
		break;
		case PEASY_FILETYPE_MIME_TYPE:
		g_value_set_string (value, peasy_filetype_get_mime_type (self));
		break;
		case PEASY_FILETYPE_ICON:
		g_value_set_object (value, peasy_filetype_get_icon (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



